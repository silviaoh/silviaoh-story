---
title: '[JavaScript.6] 실행 컨텍스트에 저장되는 정보'
date: 2021-09-11 22:09:58
category: 'JavaScript'
draft: false
---

> 이 글은 `코어 자바스크립트`를 참고하여 학습용으로 작성한 글입니다.

![](https://media.vlpt.us/images/seob/post/6e36b432-b758-4a98-889b-3d7209946fb5/image.png)

실행 컨텍스트에는 다음과 같은 3가지 정보들이 저장된다.

1. `VariableEnvironment`
2. `LexicalEnvironment`
3. `thisBinding`

## VariableEnvironment

`VariableEnvironment`에서 `Variable`은 **변수**이다. 이름만 보면 변수에 대한 정보를 저장하는 것 같지 않은가? `VariableEnvironment`에는 **현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 뒤에 나올 `LexicalEnvironment`의 스냅샷을 내용으로 보유하며 스냅샷을 유지한다.**

실행 컨텍스트를 생성할 때 `VariableEnvironment`에 정보를 먼저 담은 다음, 이것을 그대로 복사해서 `LexicalEnvironment`를 만들고, 이후에 수정할 때는 `LexicalEnvironment`를 주로 사용하게 된다.

## LexicalEnvironment

### environmentRecord

environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.

여기서 코드의 식별자 정보들이란 `한 함수에 지정된 매개변수 식별자`, 함수가 있을 경우 `그 함수 자체`, `선언된 변수의 식별자` 등이다.
컨텍스트의 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 수집한다.

> 전역 실행 컨텍스트는 변수 객체를 생성하는 대신 자바스크립트 구동 환경이 별도로 제공하는 전역 객체를 활용한다.

변수 정보를 수집하는 과정을 모두 마치더라도 아직 코드는 실행 전이다. 코드가 실행되기 전임에도 자바스크립트 엔진은 이미 해당 환경에 속한 **모든 변수 정보를 알고 있는 것이 된다. 즉, 단순히 이해시키자면 '자바스크립트 엔진은 코드 안의 모든 변수를 최상단으로 끌어올린 다음 코드를 실행한다(Hoisting)'** 라고 생각해도 괜찮다는 것이다.

### Example로 이해하는 호이스팅(Hoisting)

#### **변수를 호이스팅 할 때**

호이스팅이란 한국말로 '끌어올리다'라고 해석된다. 변수 정보를 수집할 때 컴퓨터가 아닌 사용자의 관점에서 쉽게 이해하기 위해 나타난 용어이다. 다음의 코드를 보자.

```javascript
function a(x) {
  // 수집 대상 1(매개 변수)
  console.log(x) // [1]
  var x // 수집 대상 2(변수 선언)
  console.log(x) // [2]
  var x = 2 // 수집 대상 3(변수 선언)
  console.log(x) // [3]
}

a(1)
```

이 코드에서 x의 값을 출력하면 어떤 값들이 출력될까? 호이스팅이 되지 않았을 때는 매개변수 x의 값이 출력되므로 `[1]: 1`, 변수 x가 선언이 되었지만 값이 할당되지 않았기 때문에 `[2]: undefined`, 변수 x가 선언이 되었고 2가 할당이 되었으므로 `[3]: 2`의 결과가 출력될 것이다.

하지만 실제로는 결과가 달라진다. 바로 호이스팅(Hoisting)이 일어나기 때문이다.
이제 이해하기 쉽게 실제 코드가 실행되는 방법으로 코드를 바꿔보겠다. environmentRecord는 현재 실행될 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지만 관심이 있다. 그렇기 때문에 변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다.

```javascript
function a() {
  var x // 수집 대상1 : 매개변수의 변수 선언 부분
  var x // 수집 대상2 : 변수 선언 => 변수는 선언부만 끌어올린다.
  var x // 수집 대상3 : 변수 선언
  console.log(x) // [1]
  console.log(x) // [2]
  var x = 2 // 할당 부분은 호이스팅 되지 않는다.
  console.log(x) //[ 3]
}
a(1)
```

그래서 실제로는 `[1]: 1(인자 값)`, `[2]: 1(인자 값)`, `[3]: 2`가 나온다.

#### **함수를 호이스팅 할 때**

변수가 호이스팅 될 때는 변수 선언부만 호이스팅 되고 할당부는 호이스팅 되지 않는다. 함수는 어떻게 호이스팅 될까? 다음의 코드를 보자.

```javascript
function a() {
  console.log(b) // [1]
  var b = 'bbb' // 수집 대상 1(변수 선언)
  console.log(b) // [2]
  function b() {} // 수집 대상 2(함수 선언)
  console.log(b) // [3]
}
a()
```

변수 호이스팅 예제 코드에서와 마찬가지로 출력 결과를 미리 예상해보면 [1]: err or undefined, [2]: bbb, [3]: 함수 b가 출력될 것 같다. 실제로는 과연 그럴까?

a 함수를 실행하는 순간 실행 컨텍스트가 생성된다. 이 실행 컨텍스트는 당연히 a의 실행 컨텍스트이다. 이 때, 변수명과 함수 선언의 정보를 위로 끌어올린다(수집한다). 변수는 선언부와 할당부를 나눠 선언부만 위로 끌어올렸지만 함수 선언은 함수 전체를 위로 끌어올린다.

```javascript
function a() {
  var b // 수집 대상 1(변수 선언)
  function b() {} // 수집 대상 2(함수 선언)

  console.log(b) // [1]
  b = 'bbb' // 변수의 할당부는 자리에 남겨둔다.
  console.log(b) // [2]
  console.log(b) // [3]
}
a()
```

이 코드에서 한 가지만 수정하자면, 호이스팅이 끝난 상태에서의 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것처럼 여길 수 있다.

```javascript
function a() {
  var b // 수집 대상 1(변수 선언)
  var b = function b() {} // change!

  console.log(b) // [1]
  b = 'bbb' // 변수의 할당부는 자리에 남겨둔다.
  console.log(b) // [2]
  console.log(b) // [3]
}
a()
```

변수 정보를 수집했으니 이제 코드를 실행할 차례이다.

```javascript
function a() {
  /*변수 b를 선언한다.
  이 때, 메모리에서는 변수를 저장할 공간을 미리 확보하고, 확보한 공간의 주소값을 변수 b에 연결한다.*/
  var b
  /*다시 변수 b를 선언. 함수 b를 선언된 변수 b에 할당한다.
  하지만 이미 선언된 변수 b가 있으므로 선언 과정은 무시한다.
  함수는 별도의 메모리에 담길 것이고, 그 함수가 저장된 주소값을 b와 연결된 공간(위에서 확보한 공간)에 저장한다. 이제 변수 b는 함수를 가리키게 된다.*/
  var b = function b() {}
  console.log(b) // 함수 b 출력!
  /*변수 b에 'bbb'를 할당하라. 
  b와 연결된 메모리 공간에는 이미 함수가 저장된 주소값이 담겨있었는데 이걸 'bbb'가 저장된 주소값으로 덮어쓴다. 
  이제 변수 b는 'bbb'를 가리킨다.*/
  b = 'bbb'
  console.log(b) // 'bbb'
  console.log(b) // 'bbb'
}
a()
```
